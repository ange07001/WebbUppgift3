---

---

<h3 class="title has-text-centered is-size-4">
    Mines left: <span class="has-text-primary" id="mines-left-text"></span>
</h3>
<div class="container columns is-centered">
    <div id="minesweeper-board"></div>
</div>

<div class="modal" id="minesweeper-modal">
    <div class="modal-background" id="minesweeper-modal-background"></div>
    <div class="modal-content px-5 py-5 has-background">
        <h2 class="title has-text-centered">YOU LOST!</h2>
        <p class="has-text-centered is-size-4 title">Your score is: <span class="has-text-primary">26</span></p>
        <p class="has-text-centered is-size-4 title">Time is: <span class="has-text-primary">26</span></p>
    </div>
</div>

<script>
    const BOARD_SIZE = 10;
    const NUMBER_OF_MINES = 10;
    const GAME_SIZE = 500;

    function createBoard(boardSize: number, numberOfMines: number) {
        const board = [];
        const minePositions = getMinePos(boardSize, numberOfMines);
        console.log(minePositions);
        for (let x = 0; x < boardSize; x++) {
            const row = [];
            for (let y = 0; y < boardSize; y++) {
                const element = document.createElement("div");
                updateTile(element, "hidden");
                const tile = {
                    element,
                    x,
                    y,
                    mine: minePositions.some(posMatch.bind(null, { x, y })),
                };
                row.push(tile);
            }
            board.push(row);
        }
        return board;
    }

    function updateTile(element: HTMLElement, status: string) {
        element.dataset.status = status;

        switch (status) {
            case "hidden":
                // Raised effect for hidden tiles
                element.style.backgroundColor = "#BBB";
                element.style.borderTop = "3px solid #DDD";
                element.style.borderLeft = "3px solid #DDD";
                element.style.borderRight = "3px solid #888";
                element.style.borderBottom = "3px solid #888";
                element.style.cursor = "pointer";
                break;
            case "mine":
                // Sunken effect for revealed mines
                element.style.backgroundColor = "red";
                element.style.borderTop = "2px solid #888";
                element.style.borderLeft = "2px solid #888";
                element.style.borderRight = "2px solid #CCC";
                element.style.borderBottom = "2px solid #CCC";
                element.style.cursor = "default";
                break;
            case "number":
                // Sunken effect for revealed numbers
                element.style.backgroundColor = "#DDD";
                element.style.borderTop = "2px solid #999";
                element.style.borderLeft = "2px solid #999";
                element.style.borderRight = "2px solid #CCC";
                element.style.borderBottom = "2px solid #CCC";
                element.style.cursor = "default";
                break;
            case "marked":
                // Raised effect with flag color
                element.style.backgroundColor = "yellow";
                element.style.borderTop = "3px solid #DDD";
                element.style.borderLeft = "3px solid #DDD";
                element.style.borderRight = "3px solid #888";
                element.style.borderBottom = "3px solid #888";
                element.style.cursor = "pointer";
                break;
        }
    }

    function getTileStatus(tile: {
        element: HTMLElement;
        x: number;
        y: number;
        mine: boolean;
    }) {
        return tile.element.dataset.status;
    }

    function getMinePos(boardSize: number, numberOfMines: number) {
        const positions: { x: number; y: number }[] = [];
        while (positions.length < numberOfMines) {
            const position = {
                x: random(0, boardSize),
                y: random(0, boardSize),
            };

            if (!positions.some((pos) => posMatch(pos, position))) {
                positions.push(position);
            }
        }
        return positions;
    }

    function posMatch(
        a: { x: number; y: number },
        b: { x: number; y: number },
    ) {
        return a.x === b.x && a.y === b.y;
    }

    function random(min: number, max: number) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function markTile(tile: {
        element: HTMLElement;
        x: number;
        y: number;
        mine: boolean;
    }) {
        if (
            getTileStatus(tile) !== "hidden" &&
            getTileStatus(tile) !== "marked"
        ) {
            return;
        } else {
            if (getTileStatus(tile) === "marked") {
                updateTile(tile.element, "hidden");
            } else {
                updateTile(tile.element, "marked");
            }
        }
    }

    function listMinesLeft() {
        const markedTilesCount = board.reduce((count, row) => {
            return (
                count +
                row.filter((tile) => getTileStatus(tile) === "marked").length
            );
        }, 0);

        minesLeftText.textContent = (
            NUMBER_OF_MINES - markedTilesCount
        ).toString();
    }

    function getNearbyTiles(
        board: any[][],
        tile: {
            element: HTMLElement;
            x: number;
            y: number;
            mine: boolean;
        },
    ) {
        const tiles = [];

        for (let xOffset = -1; xOffset <= 1; xOffset++) {
            for (let yOffset = -1; yOffset <= 1; yOffset++) {
                const nearbyTile = board[tile.x + xOffset]?.[tile.y + yOffset];
                if (nearbyTile) tiles.push(nearbyTile);
            }
        }
        return tiles;
    }

    function revealTile(
        board: any[][],
        tile: {
            element: HTMLElement;
            x: number;
            y: number;
            mine: boolean;
        },
    ) {
        if (getTileStatus(tile) !== "hidden") {
            return;
        }

        if (tile.mine) {
            updateTile(tile.element, "mine");
            return;
        }

        updateTile(tile.element, "number");
        const adjacentTiles = getNearbyTiles(board, tile);
        const mines = adjacentTiles.filter((t) => t.mine); // Fixed: Check for actual mines

        if (mines.length === 0) {
            adjacentTiles.forEach(revealTile.bind(null, board));
        } else {
            tile.element.textContent = mines.length.toString();

            // Center the number in the tile
            tile.element.style.display = "flex";
            tile.element.style.justifyContent = "center";
            tile.element.style.alignItems = "center";
            tile.element.style.fontWeight = "bold";

            // Add color based on number (classic Minesweeper style)
            const colors = [
                "blue",
                "green",
                "red",
                "darkblue",
                "brown",
                "cyan",
                "black",
                "gray",
            ];
            if (mines.length > 0 && mines.length <= colors.length) {
                tile.element.style.color = colors[mines.length - 1];
            }
        }
    };

    function CheckGameEnd() {
        const win = checkWin(board);
        const lose = checkLose(board);

        if (win || lose) {
            boardElement.addEventListener('click', stopProp, {capture: true});
            boardElement.addEventListener('contextmenu', stopProp, {capture: true});
        }

        if (win) {
            minesweeperModal.classList.add("is-active");
        }

        if (lose) {
            minesweeperModal.classList.add("is-active");
        }
    };

    function stopProp(e: Event) {
        e.stopImmediatePropagation()
    }

    function checkWin(board: any[][]): boolean {
        return board.every(row => {
            return row.every(tile => {
                return tile.mine || getTileStatus(tile) !== "hidden";
            });
        });
    };

    function checkLose(board: any[][]): boolean {
        return board.some(row => {
            return row.some(tile => {
                return tile.mine && getTileStatus(tile) === "mine";
            });
        });
    };


    const board = createBoard(BOARD_SIZE, NUMBER_OF_MINES);
    const boardElement = document.querySelector(
        "#minesweeper-board",
    )! as HTMLElement;
    const minesLeftText = document.querySelector(
        "#mines-left-text",
    )! as HTMLElement;

    minesLeftText.textContent = NUMBER_OF_MINES.toString();

    board.forEach((row) => {
        row.forEach((tile) => {
            boardElement.append(tile.element);
            tile.element.addEventListener("click", () => {
                revealTile(board, tile);
                CheckGameEnd();
            });
            tile.element.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                markTile(tile);
                listMinesLeft();
            });
        });
    });

    boardElement.style.setProperty("--size", BOARD_SIZE.toString());
    boardElement.style.setProperty(
        "--block-size",
        Math.round(GAME_SIZE / BOARD_SIZE).toString() + "px",
    );

    function updateBoardSize() {
        const containerWidth =
            boardElement.parentElement?.clientWidth || GAME_SIZE;
        const maxSize = Math.min(containerWidth - 20, GAME_SIZE);
        const newBlockSize = Math.floor(
            (maxSize - (BOARD_SIZE + 1) * 4) / BOARD_SIZE,
        );

        boardElement.style.setProperty("--block-size", newBlockSize + "px");
    }

    updateBoardSize();
    window.addEventListener("resize", updateBoardSize);

    // Minesweeper Modal
    const minesweeperModalBackground = document.querySelector('#minesweeper-modal-background')!;
    const minesweeperModal = document.querySelector('#minesweeper-modal')!;

    minesweeperModalBackground.addEventListener('click', () => {
        minesweeperModal.classList.remove("is-active");
    })

</script>

<style>
    #minesweeper-board {
        display: inline-grid;
        padding: 10px;
        grid-template-columns: repeat(var(--size), var(--block-size));
        grid-template-rows: repeat(var(--size), var(--block-size));
        gap: 4px;
        background-color: #777;
    }

    .modal-content {
        border-radius: 10px;
    }

</style>
